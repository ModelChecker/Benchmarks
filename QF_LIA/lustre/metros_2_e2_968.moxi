(set-logic QF_LIA)
(define-system Sofar 
   :input ((_X_ Bool)) 
   :output ((Sofar Bool) (flby Bool)) 
   :local () 
   :init (= flby _X_) 
   :trans (= flby' (and _X_' Sofar)) 
   :inv (= Sofar flby) )
(define-system controleur 
   :input ((nB Int) (nS Int)) 
   :output ((diff Int) (avance Bool) (retard Bool) (ite Bool) (flby Bool) (ite2 Bool) (flby2 Bool)) 
   :local () 
   :init (and (= flby false) (= flby2 false)) 
   :trans (and (and (and (=> (not avance) (= ite' (>= diff' 10))) (=> (not (not avance)) (= ite' (> diff' 0)))) (and (=> (not retard) (= ite2' (<= diff' (- 10)))) (=> (not (not retard)) (= ite2' (> diff' 0))))) (= flby' ite') (= flby2' ite2')) 
   :inv (and (= diff (- nB nS)) (= avance flby) (= retard flby2)) )
(define-system hypothese 
   :input ((_B_ Bool) (_S_ Bool) (avance Bool) (retard Bool)) 
   :output ((ok Bool) (c Int) (ite Bool) (ite2 Bool) (flby Bool) (ite3 Int) (ite4 Int) (flby2 Int)) 
   :local () 
   :init (and (= flby true) (= flby2 0)) 
   :trans (and (and (and (and (and (=> retard (= ite' (not _S_'))) (=> (not retard) (= ite' true))) (and (=> (>= c 9) (= ite2' (not _B_'))) (=> (not (>= c 9)) (= ite2' true)))) (and (=> _B_' (= ite3' (+ (- c 1) 1))) (=> (not _B_') (= ite3' c)))) (and (=> (and avance avance') (= ite4' ite3')) (=> (not (and avance avance')) (= ite4' 0)))) (= flby' (and ite' ite2')) (= flby2' ite4')) 
   :inv (and (= ok flby) (= c flby2)) )
(define-system _main_ 
   :input ((_B0_ Bool) (_B1_ Bool) (_S_ Bool)) 
   :output ((ast Bool) (nB0 Int) (nB1 Int) (nS Int) (diff0 Int) (diff1 Int) (avance0 Bool) (avance1 Bool) (retard0 Bool) (retard1 Bool) (_H0_ Bool) (_H1_ Bool) (ite Int) (flby Int) (ite2 Int) (flby2 Int) (ite3 Int) (flby3 Int)) 
   :local ((call_hypothese._B_ Bool) (call_hypothese._S_ Bool) (call_hypothese.avance Bool) (call_hypothese.retard Bool) (call_hypothese.ok Bool) (call_hypothese.c Int) (call_hypothese.ite Bool) (call_hypothese.ite2 Bool) (call_hypothese.flby Bool) (call_hypothese.ite3 Int) (call_hypothese.ite4 Int) (call_hypothese.flby2 Int) (call_hypothese2._B_ Bool) (call_hypothese2._S_ Bool) (call_hypothese2.avance Bool) (call_hypothese2.retard Bool) (call_hypothese2.ok Bool) (call_hypothese2.c Int) (call_hypothese2.ite Bool) (call_hypothese2.ite2 Bool) (call_hypothese2.flby Bool) (call_hypothese2.ite3 Int) (call_hypothese2.ite4 Int) (call_hypothese2.flby2 Int) (call_controleur.nB Int) (call_controleur.nS Int) (call_controleur.diff Int) (call_controleur.avance Bool) (call_controleur.retard Bool) (call_controleur.ite Bool) (call_controleur.flby Bool) (call_controleur.ite2 Bool) (call_controleur.flby2 Bool) (call_controleur2.nB Int) (call_controleur2.nS Int) (call_controleur2.diff Int) (call_controleur2.avance Bool) (call_controleur2.retard Bool) (call_controleur2.ite Bool) (call_controleur2.flby Bool) (call_controleur2.ite2 Bool) (call_controleur2.flby2 Bool)) 
   :init (and (= flby 0) (= flby2 0) (= flby3 0)) 
   :trans (and (and (and (and (=> _B0_' (= ite' (+ nB0 1))) (=> (not _B0_') (= ite' nB0))) (and (=> _B1_' (= ite2' (+ nB1 1))) (=> (not _B1_') (= ite2' nB1)))) (and (=> _S_' (= ite3' (+ nS 1))) (=> (not _S_') (= ite3' nS)))) (= flby' ite') (= flby2' ite2') (= flby3' ite3')) 
   :inv (and (= ast (and _H0_ _H1_)) (= nB0 flby) (= nB1 flby2) (= nS flby3) (= diff0 call_controleur.diff) (= diff1 call_controleur2.diff) (= avance0 call_controleur.avance) (= avance1 call_controleur2.avance) (= retard0 call_controleur.retard) (= retard1 call_controleur2.retard) (= _H0_ call_hypothese.ok) (= _H1_ call_hypothese2.ok) (= call_hypothese._B_ _B0_) (= call_hypothese._S_ _S_) (= call_hypothese.avance avance0) (= call_hypothese.retard retard0) (= call_hypothese2._B_ _B1_) (= call_hypothese2._S_ _S_) (= call_hypothese2.avance avance1) (= call_hypothese2.retard retard1) (= call_controleur.nB nB0) (= call_controleur.nS nS) (= call_controleur2.nB nB1) (= call_controleur2.nS nS)) 
   :subsys (call_hypothese (hypothese call_hypothese._B_ call_hypothese._S_ call_hypothese.avance call_hypothese.retard call_hypothese.ok call_hypothese.c call_hypothese.ite call_hypothese.ite2 call_hypothese.flby call_hypothese.ite3 call_hypothese.ite4 call_hypothese.flby2))
   :subsys (call_hypothese2 (hypothese call_hypothese2._B_ call_hypothese2._S_ call_hypothese2.avance call_hypothese2.retard call_hypothese2.ok call_hypothese2.c call_hypothese2.ite call_hypothese2.ite2 call_hypothese2.flby call_hypothese2.ite3 call_hypothese2.ite4 call_hypothese2.flby2))
   :subsys (call_controleur (controleur call_controleur.nB call_controleur.nS call_controleur.diff call_controleur.avance call_controleur.retard call_controleur.ite call_controleur.flby call_controleur.ite2 call_controleur.flby2))
   :subsys (call_controleur2 (controleur call_controleur2.nB call_controleur2.nS call_controleur2.diff call_controleur2.avance call_controleur2.retard call_controleur2.ite call_controleur2.flby call_controleur2.ite2 call_controleur2.flby2)))
(define-system main 
   :input () 
   :output ((param__B0_ Bool) (param__B1_ Bool) (param__S_ Bool) (_OK_ Bool) (nB0 Int) (nB1 Int) (nS Int) (diff0 Int) (diff1 Int) (avance0 Bool) (avance1 Bool) (retard0 Bool) (retard1 Bool) (ast Bool) (flby Bool)) 
   :local ((call__main_._B0_ Bool) (call__main_._B1_ Bool) (call__main_._S_ Bool) (call__main_.ast Bool) (call__main_.nB0 Int) (call__main_.nB1 Int) (call__main_.nS Int) (call__main_.diff0 Int) (call__main_.diff1 Int) (call__main_.avance0 Bool) (call__main_.avance1 Bool) (call__main_.retard0 Bool) (call__main_.retard1 Bool) (call__main_._H0_ Bool) (call__main_._H1_ Bool) (call__main_.ite Int) (call__main_.flby Int) (call__main_.ite2 Int) (call__main_.flby2 Int) (call__main_.ite3 Int) (call__main_.flby3 Int) (call_Sofar._X_ Bool) (call_Sofar.Sofar Bool) (call_Sofar.flby Bool)) 
   :init (= flby true) 
   :trans (= flby' (=> call_Sofar.Sofar' (and (<= (- 10) diff0) (<= diff0 20)))) 
   :inv (and (= _OK_ flby) (= nB0 call__main_.nB0) (= nB1 call__main_.nB1) (= nS call__main_.nS) (= diff0 call__main_.diff0) (= diff1 call__main_.diff1) (= avance0 call__main_.avance0) (= avance1 call__main_.avance1) (= retard0 call__main_.retard0) (= retard1 call__main_.retard1) (= ast call__main_.ast) (= call__main_._B0_ param__B0_) (= call__main_._B1_ param__B1_) (= call__main_._S_ param__S_) (= call_Sofar._X_ ast)) 
   :subsys (call__main_ (_main_ call__main_._B0_ call__main_._B1_ call__main_._S_ call__main_.ast call__main_.nB0 call__main_.nB1 call__main_.nS call__main_.diff0 call__main_.diff1 call__main_.avance0 call__main_.avance1 call__main_.retard0 call__main_.retard1 call__main_._H0_ call__main_._H1_ call__main_.ite call__main_.flby call__main_.ite2 call__main_.flby2 call__main_.ite3 call__main_.flby3))
   :subsys (call_Sofar (Sofar call_Sofar._X_ call_Sofar.Sofar call_Sofar.flby)))
(check-system main 
   :input () 
   :output ((param__B0_ Bool) (param__B1_ Bool) (param__S_ Bool) (_OK_ Bool) (nB0 Int) (nB1 Int) (nS Int) (diff0 Int) (diff1 Int) (avance0 Bool) (avance1 Bool) (retard0 Bool) (retard1 Bool) (ast Bool) (flby Bool)) 
   :local ((call__main_._B0_ Bool) (call__main_._B1_ Bool) (call__main_._S_ Bool) (call__main_.ast Bool) (call__main_.nB0 Int) (call__main_.nB1 Int) (call__main_.nS Int) (call__main_.diff0 Int) (call__main_.diff1 Int) (call__main_.avance0 Bool) (call__main_.avance1 Bool) (call__main_.retard0 Bool) (call__main_.retard1 Bool) (call__main_._H0_ Bool) (call__main_._H1_ Bool) (call__main_.ite Int) (call__main_.flby Int) (call__main_.ite2 Int) (call__main_.flby2 Int) (call__main_.ite3 Int) (call__main_.flby3 Int) (call_Sofar._X_ Bool) (call_Sofar.Sofar Bool) (call_Sofar.flby Bool)) 
   :reachable (rch_1 (not (= _OK_ true)))
   :query (qry_rch_1 (rch_1)))