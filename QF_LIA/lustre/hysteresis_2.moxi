(set-logic QF_LIA)
(define-system counter 
   :input ((_init_ Int) (incr Int) (x Bool) (reset Bool)) 
   :output ((c Int) (pc Int) (flby Int) (ite Int) (ite2 Int)) 
   :local () 
   :init (= flby _init_) 
   :trans (= flby' c) 
   :inv (and (and (and (=> (and (and x (> pc (- 1000))) (> pc 1000)) (= ite (+ pc incr))) (=> (not (and (and x (> pc (- 1000))) (> pc 1000))) (= ite pc))) (and (=> reset (= ite2 _init_)) (=> (not reset) (= ite2 ite)))) (= c ite2) (= pc flby)) )
(define-system speed 
   :input ((beacon Bool) (second Bool)) 
   :output ((late Bool) (early Bool) (diff Int) (incr Int) (ite Int) (ite2 Int) (ite3 Bool) (flby Bool) (ite4 Bool) (flby2 Bool)) 
   :local ((call_counter._init_ Int) (call_counter.incr Int) (call_counter.x Bool) (call_counter.reset Bool) (call_counter.c Int) (call_counter.pc Int) (call_counter.flby Int) (call_counter.ite Int) (call_counter.ite2 Int)) 
   :init (and (= flby false) (= flby2 false)) 
   :trans (and (and (and (=> early (= ite3' (> diff' 0))) (=> (not early) (= ite3' (>= diff' 10)))) (and (=> late (= ite4' (> diff' 0))) (=> (not late) (= ite4' (<= diff' (- 10)))))) (= flby' ite3') (= flby2' ite4')) 
   :inv (and (and (and (=> (and second (not beacon)) (= ite (- 1))) (=> (not (and second (not beacon))) (= ite 0))) (and (=> (and beacon (not second)) (= ite2 1)) (=> (not (and beacon (not second))) (= ite2 ite)))) (= late flby2) (= early flby) (= diff call_counter.c) (= incr ite2) (= call_counter._init_ 0) (= call_counter.incr incr) (= call_counter.x (or beacon second)) (= call_counter.reset false)) 
   :subsys (call_counter (counter call_counter._init_ call_counter.incr call_counter.x call_counter.reset call_counter.c call_counter.pc call_counter.flby call_counter.ite call_counter.ite2)))
(define-system main 
   :input () 
   :output ((_OK_ Bool) (late Bool) (early Bool) (flby Bool) (param_beacon Bool) (param_second Bool)) 
   :local ((call_speed.beacon Bool) (call_speed.second Bool) (call_speed.late Bool) (call_speed.early Bool) (call_speed.diff Int) (call_speed.incr Int) (call_speed.ite Int) (call_speed.ite2 Int) (call_speed.ite3 Bool) (call_speed.flby Bool) (call_speed.ite4 Bool) (call_speed.flby2 Bool)) 
   :init (= flby true) 
   :trans (= flby' (not (and late' early))) 
   :inv (and (= _OK_ flby) (= late call_speed.late) (= early call_speed.early) (= call_speed.beacon param_beacon) (= call_speed.second param_second)) 
   :subsys (call_speed (speed call_speed.beacon call_speed.second call_speed.late call_speed.early call_speed.diff call_speed.incr call_speed.ite call_speed.ite2 call_speed.ite3 call_speed.flby call_speed.ite4 call_speed.flby2)))
(check-system main 
   :input () 
   :output ((_OK_ Bool) (late Bool) (early Bool) (flby Bool) (param_beacon Bool) (param_second Bool)) 
   :local ((call_speed.beacon Bool) (call_speed.second Bool) (call_speed.late Bool) (call_speed.early Bool) (call_speed.diff Int) (call_speed.incr Int) (call_speed.ite Int) (call_speed.ite2 Int) (call_speed.ite3 Bool) (call_speed.flby Bool) (call_speed.ite4 Bool) (call_speed.flby2 Bool)) 
   :reachable (rch_1 (not (= _OK_ true)))
   :query (qry_rch_1 (rch_1)))